
# HTTP缓存机制

对于**强制缓存**，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。
对于**比较缓存**，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。

## 强制缓存

强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是如何判断缓存数据是否失效呢？
没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将**数据**和**缓存规则**一并返回，缓存规则信息包含在响应**header**中。

对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires/Cache-Control）

Expires
值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据

Cache-Control （response头）
Cache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。
private:      客户端可以缓存
public:       客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）
max-age=xxx:  缓存的内容将在 xxx 秒后失效 从请求时间 开始到过期时间之间的秒数【与字段Date进行比较】
no-cache:           需要使用对比缓存来验证缓存数据（后面介绍）
no-store:           所有内容都不会缓存，强制缓存，对比缓存都不会触发（对于前端开发来说，缓存越多越好，so...基本上和它说886）

## 对比缓存（协商缓存）

浏览器第一次请求数据时，服务器会将**缓存标识**与数据一起返回给客户端，客户端将二者备份至**缓存数据库**中。

再次请求数据时，客户端将**备份的缓存标识**发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回**304状态码**，通知客户端比较成功，可以使用缓存数据。

对比缓存来说，缓存标识的传递是我们着重需要理解的，它在请求header和响应header间进行传递，
一共分为两种标识传递

Last-Modified  /  If-Modified-Since

**Last-Modified**（response头）
服务器在**响应请求**时，告诉浏览器资源的最后修改时间。
即在reponse头里面包含：Last-Modified标识字段

**If-Modified-Since**（request头）
再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。
服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。
若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；
若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。

Etag  /  If-None-Match（优先级高于Last-Modified  /  If-Modified-Since）

**Etag**
Etag（response头）
服务器响应请求时，告诉浏览器当前资源在服务器的**唯一标识**（生成规则由服务器决定）。

**If-None-Match**
再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。
服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，
不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；
相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。
