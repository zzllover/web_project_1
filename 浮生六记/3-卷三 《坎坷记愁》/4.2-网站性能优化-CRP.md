
# 网站性能优化—CRP

CRP(Critical Rendering Path，关键渲染路径)

## 浏览器渲染一个网页的过程

构建对象模型:
文档对象模型（DOM）:
1.转换：浏览器从磁盘或网络读取HTML的原始字节，然后根据指定的文件编码格式（例如 UTF-8）将其转换为相应字符
2.令牌化：浏览器把字符转化成W3C HTML5 标准指定的各种确切的令牌，比如"<html>"、"<body>"以及其他在尖括号内的字符串。每个令牌都有特殊的含义以及它自己的一套规则
3.词法分析：生成的令牌转化为对象，这个对象定义了它们的属性及规则
4.DOM构建：最后，由于HTML标记定义了不同标签之间的关系（某些标签嵌套在其他标签中），创建的对象在树状的数据结构中互相链接，树状数据结构也捕获了原始标签定义的父子关系：HTML对象是body对象的父对象，body是p对象的父对象等等。
对应**Loading事件**中的**Parse HTML**事件，可以查看到执行这一过程所需要的时间

CSS对象模型（CSSOM）
查看CSS处理过程所花费的时间，可以在录制的时间轴中查看Rendering事件中的Recalculate Style事件：与DOM解析不同，timeline不显示单独的“Parse CSS”条目，而是在Recalculate Style事件下一同捕获CSS解析、CSSOM构建以及computed styles的递归计算

## 构建渲染树、布局及绘制

浏览器会把DOM和CSSOM组合起来构建一个渲染树（Render-tree），渲染树会捕获页面上所有可见的DOM内容以及应用在每个节点上的CSSOM样式。

构建渲染树的过程大致如下：

1. 从DOM树的根节点开始，遍历每个可见的节点
    某些节点不可见（例如 script 标签、meta 标签等），因为它们不会体现在渲染结果中，所以会被忽略
    某些通过 CSS 隐藏的节点在渲染树中也会被忽略，比如应用了 display:none 规则的节点

2. 为每一个可见的节点匹配并应用对应的CSSOM规则

3. 生成有内容和计算样式的可见节点

最终输出的就是一个包含了所有可见节点的内容及样式信息的**渲染树**。
但是我们还没有计算它们在**设备视口**（viewport）中的准确位置及尺寸大小——这就是布局（Layout）阶段要做的工作，也就是常说的**重排**（reflow）

布局过程的输出是一个“**盒子模型**”，它精确地捕获了每个元素在视口中的准确位置及尺寸大小：所有相对度量单位都被转换为屏幕上的**绝对像素**

我们已经知道了哪些节点是可见的以及它们的计算样式和几何信息，然后我们就可以把这些信息传送到最后一个阶段，即把渲染树中的每一个节点都转化到屏幕上实际的像素点。这个步骤通常被称为**绘制**（painting）或者栅格化（rasterizing）。

## 浏览器执行的步骤

1. 处理 HTML 标记，构建 DOM 树
2. 处理 CSS 标记，构建 CSSOM 树
3. 将 DOM 树和 CSSOM 树融合成渲染树
4. 根据渲染树进行布局，计算每个节点的几何信息
5. 在屏幕上绘制各个节点

## 阻塞

CRP要求DOM和CSSOM两者融合在一起才能构建渲染树。这就导致了一个性能问题：HTML和CSS都是**阻塞渲染的资源**。

**CSS**是阻塞渲染的资源：意味着在CSSOM构建完成之前，浏览器不会去渲染任何已处理的内容。尽早、尽快地把CSS下载到客户端以优化首次渲染的时间

使用CSS“媒体类型”和“媒体查询”优化阻塞渲染的CSS：

**JS**可以修改页面的内容、样式以及响应用户的交互，JS在DOM、CSSOM和JS执行之间引入了很多新的依赖关系，导致浏览器在处理和渲染页面上出现大幅延迟：

1. 当浏览器遇到<script>标签时，DOM构建会暂停，直到脚本执行完毕
2. JavaScript 执行会暂停，直到CSSOM准备就绪

在script标签里面添加async关键字

## 分析CRP性能

先定义三个用于描述CRP的词汇：

1. 关键资源：能够阻止网页首次渲染的资源
2. 关键路径长度：往返过程的数量，或者获取所有关键资源所需的总时间
3. 关键字节：网页首次渲染所需的总字节数，是所有关键资源的传输文件大小总和。

## 优化CRP总结

常规步骤：

1. 分析、描述**关键路径**：关键资源数量、字节数、关键路径长度
2. 最小化关键资源数量：删除相应资源、延迟下载、标记为**异步**资源等
3. 减少关键字节数，以减少资源下载时间（往返次数）
4. 优化剩余关键资源的加载顺序：尽可能早的下载所有关键资源，以缩短关键路径长度