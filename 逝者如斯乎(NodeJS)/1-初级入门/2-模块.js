/**
  开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。
  为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含
  的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Node环境中，一个.js文件
  就称之为一个模块（module）
 */

 /**
  * 
  * 使用模块有什么好处？
  * 提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其
  * 他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第
  * 三方的模块。
  * 
  * 模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块
  * 中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。
  */

  //总结：一个 Node.js 文件就是一个模块

  //使用
  /**
   * Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，
   * 
   * require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。
   */

   //服务端的模块放在哪里
   
var http = require("http");
//Node.js 中自带了一个叫做 http 的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。
//这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。

//Node.js 的 require 方法中的文件查找策略如下：
// Node.js 中存在 4 类模块（原生模块和3种文件模块）

//从文件模块缓存中加载
//尽管 原生模块 与 文件模块 的优先级不同，但是都会优先从 文件模块的缓存 中加载已经存在的模块。

//从原生模块加载
/**
原生模块的优先级仅次于文件模块缓存的优先级。require 方法在解析文件名之后，优先检查模块是否在
原生模块列表中。以http模块为例，尽管在目录下存在一个 http/http.js/http.node/http.json 文件，
require("http") 都不会从这些文件中加载，而是从原生模块中加载。
原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载
方式进行加载和执行。
 */

 //从文件加载
 /**
当文件模块缓存中不存在，而且不是原生模块的时候，Node.js 会解析 require 方法传入的参数，并从文
件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文
件模块的过程，其中，也有一些细节值得知晓。
  */

//require方法接受以下几种参数的传递：
//  http、fs、path等，原生模块。
//  ./mod或../mod，相对路径的文件模块。
//  /pathtomodule/mod，绝对路径的文件模块。
//  mod，非原生模块的文件模块。

//exports 和 module.exports 的使用

//如果要对外暴露属性或方法，就用 exports 就行，要暴露对象(类似class，
//包含了很多属性和方法) ，就用 module.exports。